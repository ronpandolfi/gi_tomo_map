from PIL import Image
import numpy as np
import tomopy
import scipy

from matplotlib import pyplot as plt

# This script uses a single 2d luminosity map (phantom_map.png) as a phantom domain map. The luminosity values
# correspond to different domain orientations, and should be understood to be cycle around 0-255 (representing 0-180).

# The outputs of this script are matplotlib images showing:
# 1) Domain maps separated by domain angle
# 2) Sinograms generated by treating the measurement as a conventional tomographic scan (following Esther's approach?)
# 3) Sinograms generated by an integrated "measurement" along a rotating/translating slice through the domain maps

# NOTE: this synthetic data ignores that the bragg condition (and exclusion rules) would create phi gaps


if __name__ == '__main__':
    # read luminosity map
    fn = "phantom_map.png"
    image = Image.open(fn).convert('L')

    # convert to angle (360) map
    map = (np.asarray(image) / 255 * 180).astype(int) % 180

    map_size = map.shape[0]

    # print unique domain angles
    print('angles:', np.unique(map))

    domain_maps = {angle: map == angle for angle in np.unique(map)}
    for angle, domain_map in domain_maps.items():
        plt.title(f'Domain Map @ Domain Angle: {angle} deg')
        plt.xlabel('x')
        plt.ylabel('y')
        plt.imshow(domain_map,interpolation='nearest')
        plt.show()

    # if treating this a as direct 2d projection...
    map_3d = map.reshape(1, *map.shape)
    thetas = tomopy.angles(360, 0, 360)
    sinos = {angle: tomopy.project(domain_map.reshape(1, *domain_map.shape), thetas, center=None, emission=True, pad=True) for angle, domain_map in domain_maps.items()}


    for angle, sino in sinos.items():
        plt.title(f'Conventional Sinogram @ Domain Angle: {angle} deg')
        plt.xlabel('x')
        plt.ylabel('ϕ')
        plt.imshow(np.squeeze(sino))
        plt.show()

    num = 2*map_size
    domain_sinograms = {}
    slice_factor = 2  # 1 = slice is same length as map width
    for domain_angle, domain_map in domain_maps.items():
        domain_sinogram = np.zeros((360, map_size))
        for x in range(0, map_size):
            for phi in range(0, 360):
                # get a sampling over a slice through x, phi
                x0 = x+slice_factor*map_size/2*np.sin(np.deg2rad(phi))
                y0 = map_size/2+slice_factor*map_size/2*np.cos(np.deg2rad(phi))
                x1 = x-slice_factor*map_size/2*np.sin(np.deg2rad(phi))
                y1 = map_size/2 - slice_factor*map_size/2*np.cos(np.deg2rad(phi))
                xs, ys = np.linspace(x0, x1, num), np.linspace(y0, y1, num)

                # show slice overlay
                # plt.imshow(map)
                # plt.plot([x0, x1], [y0, y1], 'ro-')
                # plt.show()
                # input()

                # (only sample the current angle)
                slice = scipy.ndimage.map_coordinates(domain_map, np.vstack((ys,xs)),
                                                      order=0,
                                                      mode='constant',
                                                      cval=0)

                # sum up slice to represent signal amplitude for current domain angle through slice
                I = np.sum(slice)

                domain_sinogram[phi, x] = I
        domain_sinograms[domain_angle] = domain_sinogram

    for angle, sino in domain_sinograms.items():
        plt.title(f'Integrated Sinogram @ Domain Angle: {angle} deg')
        plt.xlabel('x')
        plt.ylabel('ϕ')
        plt.imshow(sino)
        plt.show()
